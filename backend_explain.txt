Spiegazione Dettagliata di Ciascun File/Funzione
1. .env
Scopo: Questo file contiene le variabili d'ambiente cruciali per la configurazione dell'applicazione. Sono dati sensibili o specifici dell'ambiente (sviluppo, produzione) che non devono essere committati nel controllo versione (Git).

Contenuto Esempio:

DB_USER, DB_HOST, DB_DATABASE, DB_PASSWORD, DB_PORT: Credenziali e dettagli per la connessione al database PostgreSQL.

JWT_SECRET: Una stringa segreta usata per firmare e verificare i JSON Web Tokens (JWT) per l'autenticazione. Deve essere lunga e complessa per motivi di sicurezza.

Come viene usato: La libreria dotenv carica queste variabili nell'oggetto process.env di Node.js, rendendole accessibili in tutta l'applicazione (es. process.env.DB_USER).

2. package.json
Scopo: È il "manifesto" del progetto Node.js. Descrive il progetto, elenca le sue dipendenze e definisce script utili.

Contenuto Esempio:

name, version, description: Informazioni sul progetto.

dependencies: Elenco delle librerie di cui il progetto ha bisogno per funzionare (es. express, pg, bcryptjs).

scripts: Comandi rapidi per eseguire il progetto (es. start per avviare il server).

Come viene usato: npm install legge questo file per installare tutte le dipendenze.

3. server.js
Scopo: È il punto di ingresso principale dell'applicazione Express. Qui viene inizializzato il server, configurati i middleware globali e importate le rotte API.

Funzioni Principali:

const express = require('express');: Importa il framework Express.

const app = express();: Crea un'istanza dell'applicazione Express.

dotenv.config();: Carica le variabili dal file .env.

app.use(express.json());: Middleware globale che analizza il corpo delle richieste in formato JSON. Questo permette di leggere req.body nelle rotte.

app.use('/api/users', userRoutes);: Questo è il cuore del routing. Dice a Express che tutte le richieste che iniziano con /api/users devono essere gestite dalle rotte definite nel file userRoutes.js.

app.get('/', (req, res) => { ... });: Una rotta di base per testare che il server sia attivo.

app.listen(PORT, () => { ... });: Avvia il server Express sulla porta specificata, rendendo l'applicazione accessibile.

Middleware di gestione errori finale: Un app.use((err, req, res, next) => { ... }); con 4 argomenti è un middleware di gestione errori. Cattura qualsiasi errore che viene passato a next(error) dalle rotte o dagli altri middleware e fornisce una risposta di errore standardizzata al client.

4. config/db.js
Scopo: Gestisce la configurazione e la creazione di un pool di connessioni al database PostgreSQL.

Funzioni Principali:

const { Pool } = require('pg');: Importa la classe Pool dal driver pg. Un pool di connessioni è efficiente perché riutilizza le connessioni esistenti invece di aprirne e chiuderne una nuova per ogni richiesta.

require('dotenv').config();: Assicura che le variabili d'ambiente del DB siano caricate.

const pool = new Pool({...});: Crea un'istanza del pool di connessioni utilizzando le variabili d'ambiente.

pool.query('SELECT NOW()', ...);: Un test opzionale per verificare che la connessione al database sia stabilita correttamente all'avvio del server.

module.exports = pool;: Esporta l'oggetto pool, rendendolo disponibile ad altri file (come i controller) per eseguire query al database.

5. middlewares/auth.js
Scopo: Contiene funzioni middleware per la gestione dell'autenticazione (verifica che l'utente sia chi dice di essere) e dell'autorizzazione (verifica che l'utente abbia i permessi per eseguire un'azione).

Funzioni Principali:

exports.protect = catchAsync(async (req, res, next) => { ... });:

Questo middleware viene utilizzato per proteggere le rotte che richiedono l'autenticazione.

Verifica la presenza di un JSON Web Token (JWT) nell'header Authorization della richiesta (formato Bearer TOKEN).

Decodifica e verifica il token usando jwt.verify() con il JWT_SECRET.

Estrae l'ID utente dal token e recupera i dati dell'utente dal database.

Aggiunge l'oggetto user (con user_id, email, role) all'oggetto req (es. req.user), rendendolo disponibile ai controller successivi nella catena.

Se il token non è presente o non è valido, invia una risposta di errore 401 (Unauthorized).

next(): Se tutto va bene, passa il controllo al middleware/controller successivo.

exports.authorize = (...roles) => { ... };:

Questo è un "factory function" per middleware di autorizzazione. Prende un elenco di ruoli ('user', 'manager', 'admin') come argomenti.

Restituisce un middleware effettivo che verifica se il req.user.role (impostato dal middleware protect) è incluso nei ruoli consentiti.

Se l'utente non ha il ruolo richiesto, invia una risposta di errore 403 (Forbidden).

next(): Se l'utente è autorizzato, passa il controllo.

Come viene usato: Viene importato nelle rotte e utilizzato prima del controller per proteggere specifici endpoint. Esempio: router.get('/profile', authMiddleware.protect, userController.getProfile);

6. controllers/userController.js
Scopo: Contiene la logica di business specifica per la gestione degli utenti. Ogni funzione qui è un "handler" per una specifica rotta API.

Funzioni Principali:

const pool = require('../config/db');: Importa l'istanza del pool di connessioni al database.

const bcrypt = require('bcryptjs');: Importa la libreria per l'hashing delle password.

const jwt = require('jsonwebtoken');: Importa la libreria per lavorare con i JWT.

exports.register = catchAsync(async (req, res, next) => { ... });:

Riceve i dati di registrazione (name, surname, email, password, role) da req.body.

Esegue una validazione di base degli input.

Genera un "salt" e hash della password con bcrypt.hash().

Inserisce il nuovo utente nel database tramite pool.query().

Se l'email esiste già (errore di UNIQUE constraint), gestisce l'errore specificamente.

Genera un JWT contenente l'ID utente e il ruolo.

Invia una risposta di successo con il token JWT e i dettagli dell'utente.

exports.login = catchAsync(async (req, res, next) => { ... });:

Riceve email e password da req.body.

Cerca l'utente nel database per email.

Confronta la password fornita con l'hash memorizzato usando bcrypt.compare().

Se le credenziali sono valide, genera un JWT.

Invia una risposta di successo con il token JWT e i dettagli dell'utente.

exports.getProfile = catchAsync(async (req, res, next) => { ... });:

Questa funzione si aspetta che req.user sia già stato popolato dal middleware auth.protect.

Recupera i dettagli del profilo dell'utente autenticato dal database.

Invia i dettagli del profilo come risposta.

Come viene usato: Le funzioni di questo controller vengono chiamate dalle rotte per gestire le richieste relative agli utenti.

7. routes/userRoutes.js
Scopo: Definisce gli endpoint URL per la risorsa "utente" e li associa alle funzioni controller appropriate.

Funzioni Principali:

const express = require('express');: Importa Express.

const router = express.Router();: Crea un'istanza di un router Express. Questo permette di raggruppare rotte correlate e poi "montarle" nell'applicazione principale.

router.post('/register', userController.register);: Definisce una rotta POST per /register e la collega alla funzione register del userController.

router.post('/login', userController.login);: Definisce una rotta POST per /login e la collega alla funzione login del userController.

router.get('/profile', authMiddleware.protect, userController.getProfile);: Definisce una rotta GET per /profile. Nota l'inclusione di authMiddleware.protect prima del controller: questo significa che la richiesta passerà prima attraverso il middleware di autenticazione, e solo se autenticata, procederà al userController.getProfile.

Come viene usato: Viene importato in server.js e montato su un percorso base (/api/users).

8. utils/catchAsync.js
Scopo: È una funzione di utilità per semplificare la gestione degli errori nelle funzioni asincrone dei controller.

Funzioni Principali:

const catchAsync = fn => (req, res, next) => { ... };: Questa è una funzione di ordine superiore (high-order function). Prende una funzione asincrona (fn) come argomento e restituisce una nuova funzione.

Promise.resolve(fn(req, res, next)).catch(next);: Esegue la funzione asincrona fn. Se fn restituisce una Promise che viene rifiutata (cioè, si verifica un errore all'interno della funzione async), il blocco .catch(next) cattura l'errore e lo passa alla funzione next() di Express. Questo delega la gestione dell'errore al middleware di gestione errori globale in server.js, evitando la necessità di blocchi try-catch ripetitivi in ogni controller asincrono.

Come viene usato: Avvolge le funzioni asincrone nei controller (es. exports.register = catchAsync(async (...) => { ... });).